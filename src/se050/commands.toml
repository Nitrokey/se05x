# To be parsed by generate_commands to generate Rust code for the commands.
# The order of the TLV tags and payloads matters

# SESSION MANAGEMENT

[create_session]
cla = "NO_SM_CLA"
ins = "INS_MGMT"
p1 = "P1_DEFAULT"
p2 = "P2_SESSION_CREATE"
le = 0x0C

[create_session.payload]
TAG_1 = { name = "object_id", type = "ObjectId" }

[create_session.response]
TAG_1 = { name = "session_id", type = "SessionId" }


[exchange_session_data]
cla = "NO_SM_CLA"
ins = "INS_MGMT"
p1 = "P1_DEFAULT"
p2 = "P2_SESSION_POLICY"

[exchange_session_data.payload]
TAG_1 = { name = "session_policy", type = "SessionPolicy" }
# Default type is &'data [u8]
then = { name = "c_mac" }

[exchange_session_data.response]
then = { name = "r_mac" }

[refresh_session]
cla = "NO_SM_CLA"
ins = "INS_MGMT"
p1 = "P1_DEFAULT"
p2 = "P2_SESSION_REFRESH"

[refresh_session.payload]
TAG_POLICY = { name = "policy", type = "SessionPolicy", optional = true }

[refresh_session.response]

[close_session]
cla = "NO_SM_CLA"
ins = "INS_MGMT"
p1 = "P1_DEFAULT"
p2 = "P2_SESSION_CLOSE"

[close_session.payload]
[close_session.response]

[verify_session_user_id]
cla = "NO_SM_CLA"
ins = "INS_MGMT"
p1 = "P1_DEFAULT"
p2 = "P2_SESSION_USERID"

[verify_session_user_id.payload]
TAG_1 = { name = "user_id" }

[verify_session_user_id.response]


# TODO ScpInitializeUpdate
# TODO ScpExternalAuthenticate
# TODO ECKeySessionInternalAuthenticate
# TODO ECKeySessionGetECKAPublicKey

# MODULE MANAGEMENT

[set_lock_state]
cla = "NO_SM_CLA"
ins = "INS_MGMT"
p1 = "P1_DEFAULT"
p2 = "P2_TRANSPORT"

[set_lock_state.payload]
TAG_1 = { name = "lock_indicator", type = "TransientIndicator" }
TAG_2 = { name = "lock_state", type = "LockState" }

# TODO SetPlatformSCPRequest
# TODO SetAppletFeatures

# SECURE OBJECT MANAGEMENT

[write_ec_key]
cla = "NO_SM_CLA"
ins = "INS_WRITE"
maybe_transient = true
maybe_auth = true
p1 = "P1_EC"
maybe_p1_mask = { name =  "key_type", type = "P1KeyType" }
p2 = "P2_DEFAULT"

[write_ec_key.payload]
TAG_POLICY = { name = "policy", type = "PolicySet<'data>", optional = true }
TAG_MAX_ATTEMPTS = { name = "max_attempts", type = "Be<u16>", optional = true }
TAG_1 = { name = "object_id", type = "ObjectId" }
TAG_2 = { name = "curve", type = "EcCurve", optional = true }
TAG_3 = { name = "private_key", optional = true }
TAG_4 = { name = "public_key", optional = true }

[write_rsa_key]
cla = "NO_SM_CLA"
ins = "INS_WRITE"
maybe_transient = true
maybe_auth = true
p1 = "P1_RSA"
maybe_p1_mask = { name =  "key_type", type = "P1KeyType" }
p2 = "P2_DEFAULT"

[write_rsa_key.payload]
TAG_POLICY = { name = "policy", type = "PolicySet<'data>", optional = true }
TAG_MAX_ATTEMPTS = { name = "max_attempts", type = "Be<u16>", optional = true }
TAG_1 = { name = "object_id", type = "ObjectId" }
TAG_2 = { name = "key_size", type = "Be<u16>", optional = true }
TAG_3 = { name = "p", optional = true }
TAG_4 = { name = "q", optional = true }
TAG_5 = { name = "dp", optional = true }
TAG_6 = { name = "dq", optional = true }
TAG_7 = { name = "inv_q", optional = true }
TAG_8 = { name = "e", optional = true }
TAG_9 = { name = "d", optional = true }
TAG_10 = { name = "n", optional = true }

[gen_rsa_key]
cla = "NO_SM_CLA"
ins = "INS_WRITE"
maybe_transient = true
maybe_auth = true
p1 = "P1_RSA | P1_KEY_PAIR"
p2 = "P2_RAW"

[gen_rsa_key.payload]
TAG_POLICY = { name = "policy", type = "PolicySet<'data>", optional = true }
TAG_MAX_ATTEMPTS = { name = "max_attempts", type = "Be<u16>", optional = true }
TAG_1 = { name = "object_id", type = "ObjectId" }
TAG_2 = { name = "key_size", type = "Be<u16>", optional = true }

[write_symm_key]
cla = "NO_SM_CLA"
ins = "INS_WRITE"
maybe_transient = true
maybe_auth = true
p1 = { name = "key_type", type = "SymmKeyType" }
p2 = "P2_DEFAULT"

[write_symm_key.payload]
TAG_POLICY = { name = "policy", type = "PolicySet<'data>", optional = true }
TAG_MAX_ATTEMPTS = { name = "max_attempts", type = "Be<u16>", optional = true }
TAG_1 = { name = "object_id", type = "ObjectId" }
TAG_2 = { name = "kek_id", type = "ObjectId" }
TAG_3 = { name = "value" }

[write_binary]
cla = "NO_SM_CLA"
ins = "INS_WRITE"
maybe_transient = true
p1 = "P1_BINARY"
p2 = "P2_DEFAULT"

[write_binary.payload]
TAG_POLICY = { name = "policy", type = "PolicySet<'data>", optional = true  }
TAG_1 = { name = "object_id", type = "ObjectId" }
TAG_2 = { name = "offset", type = "Be<u16>", optional = true }
TAG_3 = { name = "file_length", type = "Be<u16>", optional = true, comment = "Only when the object does not yet exists" }
TAG_4 = { name = "data", optional = true  }

[write_user_id]
cla = "NO_SM_CLA"
ins = "INS_WRITE | INS_AUTH_OBJECT"
p1 = "P1_USERID"
p2 = "P2_DEFAULT"

[write_user_id.payload]
TAG_POLICY = { name = "policy", type = "PolicySet<'data>", optional = true }
TAG_MAX_ATTEMPTS = { name = "max_attempts", type = "Be<u8>", optional = true }
TAG_1 = { name = "object_id", type = "ObjectId" }
TAG_2 = { name = "data" }

[write_counter]
cla = "NO_SM_CLA"
ins = "INS_WRITE"
maybe_transient = true
p1 = "P1_COUNTER"
p2 = "P2_DEFAULT"

[write_counter.payload]
TAG_POLICY = { name = "policy", type = "PolicySet<'data>", optional = true }
TAG_1 = { name = "object_id", type = "ObjectId" }
TAG_2 = { name = "data", type = "CounterSize", optional = true  }
TAG_3 = { name = "value", type = "Be<u64>", optional = true  }

[write_pcr]
cla = "NO_SM_CLA"
ins = "INS_WRITE"
maybe_transient = true
p1 = "P1_PCR"
p2 = "P2_DEFAULT"

[write_pcr.payload]
TAG_POLICY = { name = "policy", type = "PolicySet<'data>", optional = true }
TAG_1 = { name = "object_id", type = "ObjectId" }
TAG_2 = { name = "initial_value", optional = true  }
TAG_3 = { name = "extend", optional = true  }

[import_object]
cla = "NO_SM_CLA"
ins = "INS_WRITE"
maybe_transient = true
p1 = "P1_DEFAULT"
p2 = "P2_IMPORT"

[import_object.payload]
TAG_1 = { name = "object_id", type = "ObjectId" }
TAG_2 = { name = "key_component", type = "RsaKeyComponent" }
TAG_3 = { name = "serialized_object", optional = true  }

# TODO import external object

[read_object]
cla = "NO_SM_CLA"
ins = "INS_READ"
p1 = "P1_DEFAULT"
p2 = "P2_DEFAULT"
le = "ExpectedLen::Max"

[read_object.payload]
TAG_1 = { name = "object_id", type = "ObjectId" }
TAG_2 = { name = "offset", type = "Be<u16>", optional = true  }
TAG_3 = { name = "length", type = "Be<u16>", optional = true  }
TAG_4 = { name = "rsa_key_component", optional = true  }

[read_object.response]
TAG_1 = { name = "data" }

[read_attest_object]
cla = "NO_SM_CLA"
ins = "INS_READ | INS_ATTEST"
p1 = "P1_DEFAULT"
p2 = "P2_DEFAULT"

[read_attest_object.payload]
TAG_1 = { name = "object_id", type = "ObjectId" }
TAG_2 = { name = "offset", type = "Be<u16>", optional = true  }
TAG_3 = { name = "length", type = "Be<u16>", optional = true  }
TAG_4 = { name = "rsa_key_component", optional = true  }
TAG_5 = { name = "attestation_object", type = "ObjectId" }
TAG_6 = { name = "attestation_algo", type = "AttestationAlgo" }
TAG_7 = { name = "freshness_random", type = "&'data [u8; 16]", optional = true  }

[read_attest_object.response]
TAG_1 = { name = "data" }
TAG_2 = { name = "attributes" } # TODO type
TAG_3 = { name = "timestamp", type = "&'data [u8; 12]" }
TAG_4 = { name = "freshness_random", type = "&'data [u8; 16]" }
TAG_5 = { name = "chip_unique_id", type = "&'data [u8; 18]" }
TAG_6 = { name = "signature" }

[export_object]
cla = "NO_SM_CLA"
ins = "INS_READ"
p1 = "P1_DEFAULT"
p2 = "P2_EXPORT"
le = "ExpectedLen::Max"

[export_object.payload]
TAG_1 = { name = "object_id", type = "ObjectId" }
TAG_2 = { name = "rsa_key_component", optional = true  }

[read_type]
cla = "NO_SM_CLA"
ins = "INS_READ"
p1 = "P1_DEFAULT"
p2 = "P2_TYPE"
le = "ExpectedLen::Max"

[read_type.payload]
TAG_1 = { name = "object_id", type = "ObjectId" }

[read_type.response]
TAG_1 = { name = "ty", type = "SecureObjectType" }
TAG_2 = { name = "transient_indicator", type = "TransientIndicator" }

[read_size]
cla = "NO_SM_CLA"
ins = "INS_READ"
p1 = "P1_DEFAULT"
p2 = "P2_SIZE"
le = "ExpectedLen::Max"

[read_size.payload]
TAG_1 = { name = "object_id", type = "ObjectId" }

[read_size.response]
TAG_1 = { name = "size", type = "Be<u64>" }

[read_id_list]
cla = "NO_SM_CLA"
ins = "INS_READ"
p1 = "P1_DEFAULT"
p2 = "P2_LIST"
le = "ExpectedLen::Max"

[read_id_list.payload]
TAG_1 = { name = "offset", type = "Be<u16>" }
TAG_2 = { name = "filter", type = "SecureObjectFilter" }

[read_id_list.response]
TAG_1 = { name = "more", type = "MoreIndicator" }
TAG_2 = { name = "ids" } # TODO type

[check_object_exists]
cla = "NO_SM_CLA"
ins = "INS_READ"
p1 = "P1_DEFAULT"
p2 = "P2_EXIST"
le = "ExpectedLen::Max"

[check_object_exists.payload]
TAG_1 = { name = "object_id", type = "ObjectId" }

[check_object_exists.response]
TAG_1 = { name = "result", type = "Se050Result" }

[delete_secure_object]
cla = "NO_SM_CLA"
ins = "INS_MGMT"
p1 = "P1_DEFAULT"
p2 = "P2_DELETE_OBJECT"

[delete_secure_object.payload]
TAG_1 = { name = "object_id", type = "ObjectId" }

# EC CURVE MANAGEMENT

[create_ec_curve]
cla = "NO_SM_CLA"
ins = "INS_WRITE"
p1 = "P1_CURVE"
p2 = "P2_CREATE"

[create_ec_curve.payload]
TAG_1 = { name = "curve", type = "EcCurve" }

[set_ec_curve_param]
cla = "NO_SM_CLA"
ins = "INS_WRITE"
p1 = "P1_CURVE"
p2 = "P2_PARAM"

[set_ec_curve_param.payload]
TAG_1 = { name = "curve", type = "EcCurve" }
TAG_2 = { name = "param", type = "EcCurveParam" }
TAG_3 = { name = "value" }

[get_ec_curve_id]
cla = "NO_SM_CLA"
ins = "INS_READ"
p1 = "P1_CURVE"
p2 = "P2_ID"

[get_ec_curve_id.payload]
TAG_1 = { name = "object_id", type = "ObjectId" }

[get_ec_curve_id.response]
TAG_1 = { name = "curve", type = "EcCurve" }

[read_ec_curve_list]
cla = "NO_SM_CLA"
ins = "INS_READ"
p1 = "P1_CURVE"
p2 = "P2_LIST"

[read_ec_curve_list.payload]

[read_ec_curve_list.response]
# TODO better type
TAG_1 = { name = "ids" }

[delete_ec_curve]
cla = "NO_SM_CLA"
ins = "INS_MGMT"
p1 = "P1_CURVE"
p2 = "P2_DELETE_OBJECT"

[delete_ec_curve.payload]
TAG_1 = { name = "curve", type = "EcCurve" }

# CRYPTO OBJECT MANAGEMENT

[create_digest_object]
cla = "NO_SM_CLA"
ins = "INS_WRITE"
p1 = "P1_CRYPTO_OBJ"
p2 = "P2_DEFAULT"

[create_digest_object.payload]
TAG_1 = { name = "id", type = "CryptoObjectId" }
TAG_2 = { name = "context", type = "CryptoContext", value = "CryptoContext::Digest" }
TAG_3 = { name = "subtype", type = "Digest" }

[create_cipher_object]
cla = "NO_SM_CLA"
ins = "INS_WRITE"
p1 = "P1_CRYPTO_OBJ"
p2 = "P2_DEFAULT"

[create_cipher_object.payload]
TAG_1 = { name = "id", type = "CryptoObjectId" }
TAG_2 = { name = "context", type = "CryptoContext", value = "CryptoContext::Cipher" }
TAG_3 = { name = "subtype", type = "CipherMode" }

[create_signature_object]
cla = "NO_SM_CLA"
ins = "INS_WRITE"
p1 = "P1_CRYPTO_OBJ"
p2 = "P2_DEFAULT"

[create_signature_object.payload]
TAG_1 = { name = "id", type = "CryptoObjectId" }
TAG_2 = { name = "context", type = "CryptoContext", value = "CryptoContext::Signature" }
TAG_3 = { name = "subtype", type = "MacAlgo" }

[read_crypto_obj_list]
cla = "NO_SM_CLA"
ins = "INS_READ"
p1 = "P1_CRYPTO_OBJ"
p2 = "P2_LIST"

[read_crypto_obj_list.payload]
[read_crypto_obj_list.response]
# TODO type
TAG_1 = { name = "list" }

[delete_crypto_obj]
cla = "NO_SM_CLA"
ins = "INS_MGMT"
p1 = "P1_CRYPTO_OBJ"
p2 = "P2_DELETE_OBJECT"

[delete_crypto_obj.payload]
TAG_1 = { name = "id", type = "CryptoObjectId" }

# EC CRYPTO OPERATIONS

## Signature

[ecdsa_sign]
cla = "NO_SM_CLA"
ins = "INS_CRYPTO"
p1 = "P1_SIGNATURE"
p2 = "P2_SIGN"
le = "ExpectedLen::Max"

[ecdsa_sign.payload]
TAG_1 = { name = "key_id", type = "ObjectId" }
TAG_2 = { name = "algo", type = "EcDsaSignatureAlgo" }
TAG_3 = { name = "data" }

[ecdsa_sign.response]
# TODO type (ASN.1 format parsing)
TAG_1 = { name = "signature" }

[eddsa_sign]
cla = "NO_SM_CLA"
ins = "INS_CRYPTO"
p1 = "P1_SIGNATURE"
p2 = "P2_SIGN"
le = "ExpectedLen::Max"

[eddsa_sign.payload]
TAG_1 = { name = "key_id", type = "ObjectId" }
TAG_2 = { name = "algo", type = "EdDsaSignatureAlgo", value = "EdDsaSignatureAlgo::Pure" }
TAG_3 = { name = "data" }

[eddsa_sign.response]
TAG_1 = { name = "signature" }

[ecdaa_sign]
cla = "NO_SM_CLA"
ins = "INS_CRYPTO"
p1 = "P1_SIGNATURE"
p2 = "P2_SIGN"
le = "ExpectedLen::Max"

[ecdaa_sign.payload]
TAG_1 = { name = "key_id", type = "ObjectId" }
TAG_2 = { name = "algo", type = "EcDaaSignatureAlgo", value = "EcDaaSignatureAlgo::EcDaa" }
TAG_3 = { name = "data", type = "[u8; 32]" }
TAG_4 = { name = "random_data", type = "[u8; 32]" }

[ecdaa_sign.response]
TAG_1 = { name = "signature" }

## Signature verification

[ecdsa_verify]
cla = "NO_SM_CLA"
ins = "INS_CRYPTO"
p1 = "P1_SIGNATURE"
p2 = "P2_VERIFY"
le = 0x03

[ecdsa_verify.payload]
TAG_1 = { name = "key_id", type = "ObjectId" }
TAG_2 = { name = "algo", type = "EcDsaSignatureAlgo" }
TAG_3 = { name = "data" }
# TODO type (ASN.1 format parsing)
TAG_5 = { name = "signature" }

[ecdsa_verify.response]
TAG_1 = { name = "result", type = "Se050Result" }

[eddsa_verify]
cla = "NO_SM_CLA"
ins = "INS_CRYPTO"
p1 = "P1_SIGNATURE"
p2 = "P2_VERIFY"
le = 0x03

[eddsa_verify.payload]
TAG_1 = { name = "key_id", type = "ObjectId" }
TAG_2 = { name = "algo", type = "EdDsaSignatureAlgo", value = "EdDsaSignatureAlgo::Pure" }
TAG_3 = { name = "data" }
TAG_5 = { name = "signature" }

[eddsa_verify.response]
TAG_1 = { name = "result", type = "Se050Result" }

## Shared secret generation

[ecdh_generate_shared_secret]
cla = "NO_SM_CLA"
ins = "INS_CRYPTO"
p1 = "P1_EC"
p2 = "P2_DH"
le = "ExpectedLen::Max"

[ecdh_generate_shared_secret.payload]
TAG_1 = { name = "key_id", type = "ObjectId" }
TAG_2 = { name = "public_key" }

[ecdh_generate_shared_secret.response]
TAG_1 = { name = "shared_secret" }

[get_random]
cla = "NO_SM_CLA"
ins = "INS_MGMT"
p1 = "P1_DEFAULT"
p2 = "P2_RANDOM"
le = "ExpectedLen::Max"

[get_random.payload]
TAG_1 = { name = "length", type = "Be<u16>" }

[get_random.response]
TAG_1 = { name = "data" }

[delete_all]
cla = "NO_SM_CLA"
ins = "INS_MGMT"
p1 = "P1_DEFAULT"
p2 = "P2_DELETE_ALL"
le = "ExpectedLen::Max"

[delete_all.payload]

